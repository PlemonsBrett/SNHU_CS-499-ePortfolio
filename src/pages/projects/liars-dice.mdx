---
layout: ../../layouts/BaseLayout.astro
title: Liar's Dice | Brett Plemons
---

# Liar's Dice

A strategic dice game implementation in C++ showcasing object-oriented design, AI opponents, and terminal-based UI.

## Project Overview

Liar's Dice is a classic bluffing game where players must balance probability, psychology, and strategic thinking. This implementation brings the game to life with intelligent AI opponents and a clean command-line interface.

## Game Rules

1. Each player starts with five dice hidden under their cup
2. Players make bids on the total quantity of a specific face value across all dice
3. Each subsequent bid must either:
   - Increase the quantity (keeping the same face value)
   - Increase the face value (with any quantity)
4. Any player can challenge the current bid
5. When challenged, all dice are revealed and counted
6. The loser of the challenge loses one die
7. Last player with dice wins!

## Technical Features

### Object-Oriented Architecture
- Clean separation of concerns with dedicated classes for Game, Player, and AI logic
- Polymorphic design allowing human and AI players to interact seamlessly
- Encapsulation of game state and player strategies

### AI Implementation
- Multiple difficulty levels with different strategic approaches
- Probability calculations for informed bidding decisions
- Bluffing and conservative play patterns based on game state
- Adaptive behavior based on remaining dice and opponents

### User Experience
- Intuitive command-line interface with clear prompts
- Color-coded output for better readability (when supported)
- Input validation and error handling
- Game state persistence between rounds

## Code Architecture

```cpp
class Player {
protected:
    std::vector<int> dice;
    std::string name;
    int diceCount;
    
public:
    virtual Bid makeBid(const GameState& state) = 0;
    virtual bool challengeDecision(const Bid& currentBid) = 0;
    void rollDice();
    void loseDie();
};

class AIPlayer : public Player {
private:
    DifficultyLevel difficulty;
    
    double calculateBidProbability(const Bid& bid);
    Bid generateStrategicBid(const GameState& state);
    
public:
    Bid makeBid(const GameState& state) override;
    bool challengeDecision(const Bid& currentBid) override;
};
```

## Key Algorithms

### Probability Calculation
The AI uses statistical analysis to evaluate bids:
- Calculates expected dice counts based on probability distributions
- Factors in known information from previous rounds
- Adjusts for player tendencies and bluffing patterns

### Strategic Decision Making
- **Conservative Play**: Focus on high-probability bids
- **Aggressive Play**: Push boundaries to force opponents into difficult positions
- **Adaptive Strategy**: Shift between styles based on game progression

## Development Process

This project demonstrates:
- **Software Design Patterns**: Strategy pattern for AI behaviors, Observer pattern for game events
- **Memory Management**: Proper use of smart pointers and RAII principles
- **Error Handling**: Robust exception handling and input validation
- **Code Organization**: Modular design with clear interfaces

## Future Enhancements

- Network multiplayer support
- Graphical user interface
- Tournament mode with statistics tracking
- Machine learning-based AI opponents
- Custom rule variations

## Skills Demonstrated

- **C++ Proficiency**: Modern C++ features including STL, smart pointers, and lambdas
- **Algorithm Design**: Probability calculations and strategic decision trees
- **Software Architecture**: Clean, maintainable, and extensible codebase
- **User Experience**: Thoughtful interface design for command-line applications

This project showcases the intersection of game design, artificial intelligence, and software engineering principles, demonstrating how complex systems can be built with clean, maintainable code.